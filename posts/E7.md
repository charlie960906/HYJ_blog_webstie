---
title: Test_Post7 TypeScript 最佳實踐指南
date: 2025-01-20
summary: 分享 TypeScript 開發中的最佳實踐，包括型別設計、專案配置、效能優化等方面
tags: 技術, TypeScript, 前端開發
category: information
---

# TypeScript 最佳實踐指南

TypeScript 已經成為現代前端開發的標準工具，本文將分享一些在實際專案中總結出的最佳實踐。

## 型別設計原則

### 1. 優先使用 interface 而非 type

```typescript
// ✅ 推薦
interface User {
  id: number;
  name: string;
  email: string;
}

// ❌ 避免（除非需要聯合型別）
type User = {
  id: number;
  name: string;
  email: string;
};
```

### 2. 善用泛型

```typescript
// ✅ 泛型函數
function createApiResponse<T>(data: T): ApiResponse<T> {
  return {
    success: true,
    data,
    timestamp: Date.now()
  };
}

// ✅ 泛型介面
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
  delete(id: string): Promise<void>;
}
```

### 3. 使用 readonly 保護資料

```typescript
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
  readonly retries: number;
}

// 或使用 Readonly utility type
type ReadonlyConfig = Readonly<{
  apiUrl: string;
  timeout: number;
  retries: number;
}>;
```

## 專案配置最佳實踐

### tsconfig.json 設定

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### ESLint 配置

```javascript
module.exports = {
  extends: [
    '@typescript-eslint/recommended',
    '@typescript-eslint/recommended-requiring-type-checking'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'error'
  }
};
```

## 錯誤處理

### 1. 使用 Result 模式

```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await userService.getById(id);
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}

// 使用
const result = await fetchUser('123');
if (result.success) {
  console.log(result.data.name); // 型別安全
} else {
  console.error(result.error.message);
}
```

### 2. 自定義錯誤類型

```typescript
abstract class AppError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;
  
  constructor(message: string, public readonly context?: Record<string, any>) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

class ValidationError extends AppError {
  readonly statusCode = 400;
  readonly isOperational = true;
}

class NotFoundError extends AppError {
  readonly statusCode = 404;
  readonly isOperational = true;
}
```

## 效能優化

### 1. 使用 const assertions

```typescript
// ✅ 使用 const assertion
const themes = ['light', 'dark'] as const;
type Theme = typeof themes[number]; // 'light' | 'dark'

// ❌ 避免
const themes: string[] = ['light', 'dark'];
type Theme = string; // 太寬泛
```

### 2. 延遲型別評估

```typescript
// ✅ 使用函數型別而非立即評估
type LazyComputed<T> = () => T;

interface ExpensiveOperation {
  compute: LazyComputed<ComplexResult>;
}

// 只在需要時才計算
const result = operation.compute();
```

### 3. 避免過度使用 any

```typescript
// ❌ 避免
function processData(data: any): any {
  return data.someProperty;
}

// ✅ 使用泛型或 unknown
function processData<T>(data: T): T extends { someProperty: infer U } ? U : never {
  return (data as any).someProperty;
}

// 或使用 unknown
function processData(data: unknown): unknown {
  if (typeof data === 'object' && data !== null && 'someProperty' in data) {
    return (data as { someProperty: unknown }).someProperty;
  }
  throw new Error('Invalid data structure');
}
```

## React 與 TypeScript

### 1. 組件 Props 型別

```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  children: React.ReactNode;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

const Button: React.FC<ButtonProps> = ({ 
  variant, 
  size = 'medium', 
  disabled = false, 
  children, 
  onClick 
}) => {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

### 2. Hook 型別

```typescript
// 自定義 Hook
function useApi<T>(url: string): {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
} {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const response = await fetch(url);
      const result = await response.json() as T;
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

// 使用
const { data, loading, error } = useApi<User[]>('/api/users');
```

## 測試最佳實踐

### 1. 型別測試

```typescript
// 使用 TypeScript 編譯器 API 進行型別測試
import { expectType } from 'tsd';

// 測試函數回傳型別
declare function add(a: number, b: number): number;
expectType<number>(add(1, 2));

// 測試泛型推斷
declare function identity<T>(arg: T): T;
expectType<string>(identity('hello'));
```

### 2. Mock 型別

```typescript
// 使用 jest 與 TypeScript
import { jest } from '@jest/globals';

interface UserService {
  getById(id: string): Promise<User>;
  create(user: Omit<User, 'id'>): Promise<User>;
}

const mockUserService: jest.Mocked<UserService> = {
  getById: jest.fn(),
  create: jest.fn()
};

// 測試中使用
mockUserService.getById.mockResolvedValue({
  id: '1',
  name: 'John Doe',
  email: 'john@example.com'
});
```

## 常見陷阱與解決方案

### 1. 避免型別斷言濫用

```typescript
// ❌ 避免
const user = response.data as User;

// ✅ 使用型別保護
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'string' && typeof obj.name === 'string';
}

if (isUser(response.data)) {
  // 型別安全
  console.log(response.data.name);
}
```

### 2. 處理 null 和 undefined

```typescript
// ✅ 使用 optional chaining 和 nullish coalescing
const userName = user?.profile?.name ?? 'Unknown';

// ✅ 使用型別保護
function processUser(user: User | null | undefined): void {
  if (!user) return;
  
  // 此時 user 確定不是 null 或 undefined
  console.log(user.name);
}
```

### 3. 正確使用 Union Types

```typescript
// ✅ 使用 discriminated unions
type APIResponse = 
  | { status: 'success'; data: any }
  | { status: 'error'; message: string };

function handleResponse(response: APIResponse): void {
  if (response.status === 'success') {
    // TypeScript 知道這是成功的回應
    console.log(response.data);
  } else {
    // TypeScript 知道這是錯誤的回應
    console.error(response.message);
  }
}
```

## 工具與生態系統

### 1. 推薦工具

- **tsc**: TypeScript 編譯器
- **ts-node**: 直接執行 TypeScript
- **typescript-eslint**: ESLint 的 TypeScript 支援
- **prettier**: 程式碼格式化
- **tsd**: 型別定義測試

### 2. 編輯器配置

```json
// VS Code settings.json
{
  "typescript.preferences.importModuleSpecifier": "relative",
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.suggest.completeFunctionCalls": true
}
```

## 總結

TypeScript 的最佳實踐是一個持續演進的過程，以下是核心原則：

1. **型別安全第一**：充分利用 TypeScript 的型別系統
2. **漸進式採用**：可以逐步在現有專案中引入 TypeScript
3. **工具整合**：善用 IDE 和開發工具的支援
4. **持續學習**：關注 TypeScript 的新特性和最佳實踐

通過遵循這些實踐，可以讓 TypeScript 專案更加穩定、可維護，並提供更好的開發體驗。